package de.uni_passau.fim.se2.sa.slicing.graph;

import br.usp.each.saeg.asm.defuse.Variable;
import de.uni_passau.fim.se2.sa.slicing.cfg.ProgramGraph;
import org.objectweb.asm.tree.AbstractInsnNode;
import org.objectweb.asm.tree.ClassNode;
import org.objectweb.asm.tree.MethodNode;

public class DataDependenceGraph extends Graph {

  DataDependenceGraph(ClassNode pClassNode, MethodNode pMethodNode) {
    super(pClassNode, pMethodNode);
  }

  /**
   * Computes the data-dependence graph from the control-flow graph.
   *
   * <p>This requires the computation of the reaching-definition algorithm. We recommend using the
   * provided {@link DataFlowAnalysis} implementation.
   *
   * <p>Remember that the CFG stores for each node the instruction at that node. With that, calling
   * {@link DataFlowAnalysis#definedBy(String, MethodNode, AbstractInsnNode)} provides a collection
   * of {@link Variable}s that are defined by this particular instruction; calling {@link
   * DataFlowAnalysis#usedBy(String, MethodNode, AbstractInsnNode)} provides a collection of {@link
   * Variable}s that are used by this particular instruction, respectively. From this information
   * you can compute for each node n in the CFG the GEN[n] and KILL[n] sets. Afterwards, it is
   * possible to compute the IN[n] and OUT[n] sets using the reaching-definitions algorithm.
   *
   * <p>Finally, you can compute all def-use pairs and construct the data-dependence graph from
   * these pairs.
   *
   * @return The data-dependence graph for a control-flow graph
   */
  @Override
  public ProgramGraph computeResult() {
    if (cfg == null) {
      return null;
    }
    
    ProgramGraph ddg = new ProgramGraph();
    
    // Add all nodes from CFG to DDG
    for (de.uni_passau.fim.se2.sa.slicing.cfg.Node node : cfg.getNodes()) {
      ddg.addNode(node);
    }
    
    try {
      // Step 1: Compute GEN and KILL sets for each node
      java.util.Map<de.uni_passau.fim.se2.sa.slicing.cfg.Node, java.util.Set<DefUse>> genSets = new java.util.HashMap<>();
      java.util.Map<de.uni_passau.fim.se2.sa.slicing.cfg.Node, java.util.Set<DefUse>> killSets = new java.util.HashMap<>();
      
      // Collect all definitions in the method for computing KILL sets
      java.util.Set<DefUse> allDefs = new java.util.HashSet<>();
      
      for (de.uni_passau.fim.se2.sa.slicing.cfg.Node node : cfg.getNodes()) {
        AbstractInsnNode instruction = node.getInstruction();
        java.util.Set<DefUse> gen = new java.util.HashSet<>();
        
        // GEN[n] = definitions generated by this node
        java.util.Collection<Variable> definedVars = DataFlowAnalysis.definedBy(
            classNode.name, methodNode, instruction);
        for (Variable var : definedVars) {
          DefUse def = new DefUse(node, var);
          gen.add(def);
          allDefs.add(def);
        }
        genSets.put(node, gen);
      }
      
      // Compute KILL sets
      for (de.uni_passau.fim.se2.sa.slicing.cfg.Node node : cfg.getNodes()) {
        AbstractInsnNode instruction = node.getInstruction();
        java.util.Set<DefUse> kill = new java.util.HashSet<>();
        
        // KILL[n] = all other definitions of variables defined in this node
        java.util.Collection<Variable> definedVars = DataFlowAnalysis.definedBy(
            classNode.name, methodNode, instruction);
        
        for (Variable var : definedVars) {
          for (DefUse def : allDefs) {
            if (!def.getNode().equals(node) && variablesEqual(def.getVariable(), var)) {
              kill.add(def);
            }
          }
        }
        killSets.put(node, kill);
      }
      
      // Step 2: Compute IN and OUT sets using reaching definitions algorithm
      java.util.Map<de.uni_passau.fim.se2.sa.slicing.cfg.Node, java.util.Set<DefUse>> inSets = new java.util.HashMap<>();
      java.util.Map<de.uni_passau.fim.se2.sa.slicing.cfg.Node, java.util.Set<DefUse>> outSets = new java.util.HashMap<>();
      
      // Initialize IN and OUT sets
      for (de.uni_passau.fim.se2.sa.slicing.cfg.Node node : cfg.getNodes()) {
        inSets.put(node, new java.util.HashSet<>());
        outSets.put(node, new java.util.HashSet<>());
      }
      
      // Iterative algorithm
      boolean changed = true;
      while (changed) {
        changed = false;
        
        for (de.uni_passau.fim.se2.sa.slicing.cfg.Node node : cfg.getNodes()) {
          // IN[n] = union of OUT[p] for all predecessors p of n
          java.util.Set<DefUse> newIn = new java.util.HashSet<>();
          for (de.uni_passau.fim.se2.sa.slicing.cfg.Node pred : cfg.getPredecessors(node)) {
            newIn.addAll(outSets.get(pred));
          }
          
          // OUT[n] = GEN[n] âˆª (IN[n] - KILL[n])
          java.util.Set<DefUse> newOut = new java.util.HashSet<>(genSets.get(node));
          java.util.Set<DefUse> inMinusKill = new java.util.HashSet<>(newIn);
          inMinusKill.removeAll(killSets.get(node));
          newOut.addAll(inMinusKill);
          
          // Check if anything changed
          if (!newIn.equals(inSets.get(node)) || !newOut.equals(outSets.get(node))) {
            changed = true;
          }
          
          inSets.put(node, newIn);
          outSets.put(node, newOut);
        }
      }
      
      // Step 3: Build data dependence graph from def-use pairs
      for (de.uni_passau.fim.se2.sa.slicing.cfg.Node node : cfg.getNodes()) {
        AbstractInsnNode instruction = node.getInstruction();
        
        // Find variables used by this node
        java.util.Collection<Variable> usedVars = DataFlowAnalysis.usedBy(
            classNode.name, methodNode, instruction);
        
        for (Variable usedVar : usedVars) {
          // Find all definitions that reach this use
          for (DefUse def : inSets.get(node)) {
            if (variablesEqual(def.getVariable(), usedVar)) {
              // Add edge from definition node to use node
              ddg.addEdge(def.getNode(), node);
            }
          }
        }
      }
      
    } catch (Exception e) {
      // Handle any analysis exceptions
      e.printStackTrace();
    }
    
    return ddg;
  }
  
  // Helper class to represent a definition with variable slot information
  private static class DefUse {
    private final de.uni_passau.fim.se2.sa.slicing.cfg.Node node;
    private final Variable variable;
    private final String variableKey; // Used for semantic comparison
    
    public DefUse(de.uni_passau.fim.se2.sa.slicing.cfg.Node node, Variable variable) {
      this.node = node;
      this.variable = variable;
      // Create a key that represents the semantic meaning of the variable
      this.variableKey = createVariableKey(variable);
    }
    
    public de.uni_passau.fim.se2.sa.slicing.cfg.Node getNode() {
      return node;
    }
    
    public Variable getVariable() {
      return variable;
    }
    
    public String getVariableKey() {
      return variableKey;
    }
    
    // Create a semantic key for variable comparison
    private String createVariableKey(Variable var) {
      if (var == null) return "null";
      // For now, use the variable's toString or hashcode as a semantic identifier
      // This is a simplification - in a complete implementation, you'd want to 
      // track variable slots, field names, etc.
      return var.toString();
    }
    
    @Override
    public boolean equals(Object obj) {
      if (this == obj) return true;
      if (obj == null || getClass() != obj.getClass()) return false;
      DefUse defUse = (DefUse) obj;
      return java.util.Objects.equals(node, defUse.node) && 
             java.util.Objects.equals(variableKey, defUse.variableKey);
    }
    
    @Override
    public int hashCode() {
      return java.util.Objects.hash(node, variableKey);
    }
  }
  
  // Helper method to compare variables semantically
  private static boolean variablesEqual(Variable var1, Variable var2) {
    if (var1 == null && var2 == null) return true;
    if (var1 == null || var2 == null) return false;
    // Use identity comparison as required by VariableImpl
    return var1 == var2;
  }
}
